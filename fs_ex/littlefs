// Configuration provided during initialization of the littlefs
struct lfs_config {
	// Opaque user provided context that can be used to pass
	// information to the block device operations
	void *context;

	// Read a region in a block. Negative error codes are propogated
	// to the user.
	int (*read)(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, void *buffer, lfs_size_t size);

	// Program a region in a block. The block must have previously
	// been erased. Negative error codes are propogated to the user.
	// May return LFS_ERR_CORRUPT if the block should be considered bad.
	int (*prog)(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, const void *buffer, lfs_size_t size);

	// Erase a block. A block must be erased before being programmed.
	// The state of an erased block is undefined. Negative error codes
	// are propogated to the user.
	// May return LFS_ERR_CORRUPT if the block should be considered bad.
	int (*erase)(const struct lfs_config *c, lfs_block_t block);

	// Sync the state of the underlying block device. Negative error codes
	// are propogated to the user.
	int (*sync)(const struct lfs_config *c);

#ifdef LFS_THREADSAFE
	// Lock the underlying block device. Negative error codes
	// are propogated to the user.
	int (*lock)(const struct lfs_config *c);

	// Unlock the underlying block device. Negative error codes
	// are propogated to the user.
	int (*unlock)(const struct lfs_config *c);
#endif

	// Minimum size of a block read. All read operations will be a
	// multiple of this value.
	lfs_size_t read_size;

	// Minimum size of a block program. All program operations will be a
	// multiple of this value.
	lfs_size_t prog_size;

	// Size of an erasable block. This does not impact ram consumption and
	// may be larger than the physical erase size. However, non-inlined files
	// take up at minimum one block. Must be a multiple of the read
	// and program sizes.
	lfs_size_t block_size;

	// Number of erasable blocks on the device.
	lfs_size_t block_count;

	// Number of erase cycles before littlefs evicts metadata logs and moves
	// the metadata to another block. Suggested values are in the
	// range 100-1000, with large values having better performance at the cost
	// of less consistent wear distribution.
	//
	// Set to -1 to disable block-level wear-leveling.
	int32_t block_cycles;

	// Size of block caches. Each cache buffers a portion of a block in RAM.
	// The littlefs needs a read cache, a program cache, and one additional
	// cache per file. Larger caches can improve performance by storing more
	// data and reducing the number of disk accesses. Must be a multiple of
	// the read and program sizes, and a factor of the block size.
	lfs_size_t cache_size;

	// Size of the lookahead buffer in bytes. A larger lookahead buffer
	// increases the number of blocks found during an allocation pass. The
	// lookahead buffer is stored as a compact bitmap, so each byte of RAM
	// can track 8 blocks. Must be a multiple of 8.
	lfs_size_t lookahead_size;

	// Optional statically allocated read buffer. Must be cache_size.
	// By default lfs_malloc is used to allocate this buffer.
	void *read_buffer;

	// Optional statically allocated program buffer. Must be cache_size.
	// By default lfs_malloc is used to allocate this buffer.
	void *prog_buffer;

	// Optional statically allocated lookahead buffer. Must be lookahead_size
	// and aligned to a 32-bit boundary. By default lfs_malloc is used to
	// allocate this buffer.
	void *lookahead_buffer;

	// Optional upper limit on length of file names in bytes. No downside for
	// larger names except the size of the info struct which is controlled by
	// the LFS_NAME_MAX define. Defaults to LFS_NAME_MAX when zero. Stored in
	// superblock and must be respected by other littlefs drivers.
	lfs_size_t name_max;

	// Optional upper limit on files in bytes. No downside for larger files
	// but must be <= LFS_FILE_MAX. Defaults to LFS_FILE_MAX when zero. Stored
	// in superblock and must be respected by other littlefs drivers.
	lfs_size_t file_max;

	// Optional upper limit on custom attributes in bytes. No downside for
	// larger attributes size but must be <= LFS_ATTR_MAX. Defaults to
	// LFS_ATTR_MAX when zero.
	lfs_size_t attr_max;

	// Optional upper limit on total space given to metadata pairs in bytes. On
	// devices with large blocks (e.g. 128kB) setting this to a low size (2-8kB)
	// can help bound the metadata compaction time. Must be <= block_size.
	// Defaults to block_size when zero.
	lfs_size_t metadata_max;
};